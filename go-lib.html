<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>Verificando sesión…</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
body{margin:0;background:#000;color:#fff;font-family:sans-serif;display:grid;place-items:center;height:100vh;text-align:center}
.loading{font-size:1.2em;opacity:.9}
.debug{position:fixed;left:8px;bottom:8px;background:#111;color:#fff;padding:8px 10px;border-radius:8px;font-size:12px;max-width:90%}
</style>
</head>
<body>
<div class="loading">Verificando sesión…</div>
<div id="dbg" class="debug" aria-hidden="true" style="display:none">debug</div>

<script>
/* idb-helper con fallback a localStorage y logs visibles */
(function (w) {
  const DB_NAME = 'tp-db';
  const STORE = 'session';
  let _dbPromise = null;

  function openDB() {
    if (_dbPromise) return _dbPromise;
    _dbPromise = new Promise((resolve, reject) => {
      try {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(STORE)) {
            db.createObjectStore(STORE, { keyPath: 'k' });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      } catch (err) {
        reject(err);
      }
    });
    return _dbPromise;
  }

  async function idbPut(k, v) {
    try {
      const db = await openDB();
      return new Promise((res, rej) => {
        const tx = db.transaction(STORE, 'readwrite');
        tx.objectStore(STORE).put({ k, v });
        tx.oncomplete = () => res(true);
        tx.onerror = () => rej(tx.error);
      });
    } catch (err) {
      try {
        localStorage.setItem(k, JSON.stringify(v));
        return true;
      } catch (e) {
        throw err;
      }
    }
  }

  async function idbGet(k) {
    try {
      const db = await openDB();
      return new Promise((res, rej) => {
        const tx = db.transaction(STORE, 'readonly');
        const r = tx.objectStore(STORE).get(k);
        r.onsuccess = () => res(r.result ? r.result.v : null);
        r.onerror = () => rej(tx.error);
      });
    } catch (err) {
      try {
        const v = localStorage.getItem(k);
        return v ? JSON.parse(v) : null;
      } catch (e) {
        return null;
      }
    }
  }

  w.idbHelper = { idbPut, idbGet };
})(window);
</script>

<script>
const DOOR = 'https://script.google.com/macros/s/AKfycby2m0GoCweLlCLbnQVPwFRC3wPOpK3Zd7Qj6dZ55_N2urmatJmTl_6yaXUgWkkPvcY/exec';
const VALIDATION_ENDPOINT = 'https://script.google.com/macros/s/AKfycbz8d_Zx_iK2Yn8ojMQGjrTigZIKlGpKyM_ln4-zFAeG7vL62550SdHa-szs3ZEAui8E/exec';
const DBG = document.getElementById('dbg');

function dbgShow(msg) { DBG.style.display = 'block'; DBG.textContent = msg; }

function ckGet(name) {
  const v = ('; ' + document.cookie).split('; ' + name + '=');
  return v.length > 1 ? decodeURIComponent(v.pop().split(';').shift() || '') : '';
}

async function validateRemoteByEmail(email) {
  try {
    const res = await fetch(VALIDATION_ENDPOINT + '?email=' + encodeURIComponent(email));
    if (!res.ok) throw new Error('validation-not-ok:' + res.status);
    return await res.json();
  } catch (e) {
    console.error('Remote validation error', e);
    return null;
  }
}

(async function main() {
  try {
    const tkIdb = await idbHelper.idbGet('tp_token_v1');
    const redirIdb = await idbHelper.idbGet('tp_redirect');
    const emailIdb = await idbHelper.idbGet('tp_email');

    const tkLocal = localStorage.getItem('tp_token_v1') || '';
    const redirLocal = localStorage.getItem('tp_redirect') || '';
    const emailLocal = localStorage.getItem('tp_email') || '';

    let tk = tkIdb || tkLocal || ckGet('tp_token_v1') || '';
    let redir = redirIdb || redirLocal || ckGet('tp_redirect') || '';
    let email = emailIdb || emailLocal || ckGet('tp_email') || '';

    dbgShow('idb:' + Boolean(tkIdb) + ' email:' + (email ? email : '[none]'));

    if (tk && redir && redir !== '/') {
      location.replace(redir);
      return;
    }

    if (!email) {
      location.replace(DOOR);
      return;
    }

    const remote = await validateRemoteByEmail(email);
    if (remote && remote.valid && remote.redirect && remote.redirect !== '/') {
      await idbHelper.idbPut('tp_token_v1', remote.token);
      await idbHelper.idbPut('tp_redirect', remote.redirect);
      await idbHelper.idbPut('tp_email', email);

      localStorage.setItem('tp_token_v1', remote.token);
      localStorage.setItem('tp_redirect', remote.redirect);
      document.cookie = 'tp_token_v1=' + encodeURIComponent(remote.token) + '; path=/; max-age=31536000; SameSite=None; Secure';
      document.cookie = 'tp_redirect=' + encodeURIComponent(remote.redirect) + '; path=/; max-age=31536000; SameSite=None; Secure';

      location.replace(remote.redirect);
      return;
    }

    // Si validación remota falla y hay token/redirect locales, permitir avance
    if (tk && redir) {
      location.replace(redir);
      return;
    }

    location.replace(DOOR);
  } catch (err) {
    console.error('Verification error', err);
    const tkFallback = localStorage.getItem('tp_token_v1') || ckGet('tp_token_v1') || '';
    const redirFallback = localStorage.getItem('tp_redirect') || ckGet('tp_redirect') || '';
    const emailFallback = localStorage.getItem('tp_email') || ckGet('tp_email') || '';
    if (tkFallback && redirFallback) {
      location.replace(redirFallback);
      return;
    }
    if (!emailFallback) {
      location.replace(DOOR);
      return;
    }
    location.replace(DOOR);
  }
})();
</script>
</body>
</html>
